package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;
import rs.ac.bg.etf.pp1.ast.*;


parser code {:
	
	boolean errorDetected = false;
	Logger log = Logger.getLogger(getClass());
   
    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
		done_parsing();
		report_error(message, info);
    }
  
    public void syntax_error(Symbol cur_token) {
        report_error("\nSyntax error", cur_token);
    }
  
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatal error, parsing cannot continue", cur_token);
    }

    public void report_error(String message, Object info) {
    	errorDetected = true;
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" (line ").append(((Symbol)info).left).append(")");
        else if (info instanceof Integer) {
			msg.append (" (line ").append((int)info).append(")");
		}
        log.error(msg.toString());
    }
    
:}

scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null) 
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}


terminal PROGRAM, BREAK, CLASS, ELSE, CONST, IF, NEW, PRINT, READ, RETURN;
terminal VOID, EXTENDS, CONTINUE, FOR, STATIC, NAMESPACE, CHARCONST, BOOLCONST;
terminal PLUS, MINUS, MUL, DIV, MOD, EQUAL, NOT_EQUAL, GREATER_THAN, GREATER_EQUAL, LESS_THAN, LESS_EQUAL;
terminal AND, OR, ASSIGN, INC, DEC, SEMI, DOUBLE_COLON, COMMA, DOT, LPAREN, RPAREN, LBRACKET, RBRACKET, LBRACE, RBRACE;

terminal String IDENT;
terminal Integer NUMCONST;

nonterminal Namespace Namespace;
nonterminal GlobalDecls GlobalDecls;
nonterminal GlobalDecl GlobalDecl;
nonterminal ConstDecl ConstDecl;
nonterminal ConstDecls ConstDecls;
nonterminal ConstDeclSingle ConstDeclSingle;
nonterminal ConstValue ConstValue;
nonterminal VarDecl VarDecl;
nonterminal VarDecls VarDecls;
nonterminal VarDeclSingle VarDeclSingle;
nonterminal LocalVarDecls LocalVarDecls;
nonterminal VarArr VarArr;
nonterminal MethodDecls MethodDecls;
nonterminal FormPars FormPars;
nonterminal Type Type;
nonterminal Statements Statements;
nonterminal Statement Statement;
nonterminal DesignStatements DesignStatements;
nonterminal DesignStatement DesignStatement;
nonterminal Designs Designs;
nonterminal Design Design;
nonterminal DesignPart DesignPart;
nonterminal ActPars ActPars;
nonterminal Condition Condition;
nonterminal CondTerm CondTerm;
nonterminal CondFact CondFact;
nonterminal Expr Expr;
nonterminal ExprPart ExprPart;
nonterminal Term Term;
nonterminal Factor Factor;
nonterminal Relops Relops;
nonterminal Addops Addops;
nonterminal Mulops Mulops;
nonterminal ElseStatement ElseStatement;
nonterminal ClassDecl ClassDecl;
nonterminal Extends Extends;
nonterminal ClassMethodDecls ClassMethodDecls;
nonterminal StaticVarDecl StaticVarDecl;
nonterminal StaticInitializer StaticInitializer;
nonterminal StaticInitializers StaticInitializers;
nonterminal StaticThings StaticThings;

nonterminal rs.etf.pp1.symboltable.concepts.Obj ProgName, Program;

precedence left ELSE;

Program 	::= 
			(Program) ProgName:P1 Namespace:N2 GlobalDecls:G3 LBRACE MethodDecls:M4 RBRACE {: RESULT=new Program(P1, N2, G3, M4); RESULT.setLine(P1left); :};

ProgName 	::= 
			(ProgName) PROGRAM IDENT:progName {: RESULT=new ProgName(progName); RESULT.setLine(progNameleft); :};

Namespace 	::= 
			(ANamespace) Namespace:N1 NAMESPACE IDENT:I2 LBRACE GlobalDecls:G3 LBRACE MethodDecls:M4 RBRACE RBRACE {: RESULT=new ANamespace(N1, I2, G3, M4); RESULT.setLine(N1left); :}
			| (NoNamespace) {: RESULT=new NoNamespace(); :} /* epsilon */;
			
GlobalDecls ::= 
			(GlobDecls) GlobalDecls:G1 GlobalDecl:G2 {: RESULT=new GlobDecls(G1, G2); RESULT.setLine(G1left); :}
			| (NoGlobDecls) {: RESULT=new NoGlobDecls(); :} /* epsilon */;

GlobalDecl 	::= 
			(GlobDeclConst) ConstDecl:C1 {: RESULT=new GlobDeclConst(C1); RESULT.setLine(C1left); :} 
			| (GlobDeclVar) VarDecl:V1 {: RESULT=new GlobDeclVar(V1); RESULT.setLine(V1left); :}
			| (GlobDeclClass) ClassDecl:C1 {: RESULT=new GlobDeclClass(C1); RESULT.setLine(C1left); :};

ConstDecl 	::= 
			(ConstDecl) CONST Type:T1 ConstDecls:C2 SEMI {: RESULT=new ConstDecl(T1, C2); RESULT.setLine(T1left); :};

ConstDeclSingle ::= 
			(SingleConstDecl) IDENT:name ASSIGN ConstValue:C1 {: RESULT=new SingleConstDecl(name, C1); RESULT.setLine(nameleft); :};

ConstDecls 	::= 
			(ListConstDecls) ConstDeclSingle:C1 COMMA ConstDecls:C2 {: RESULT=new ListConstDecls(C1, C2); RESULT.setLine(C1left); :}
			| (ErrListConstDecls) error:l
			{: parser.report_error("Error during const declaration, recovery to comma(,) ", lleft); :} 
			COMMA ConstDecls:C1 {: RESULT=new ErrListConstDecls(C1); RESULT.setLine(C1left); :}
			| (SingleConstDecls) ConstDeclSingle:C1 {: RESULT=new SingleConstDecls(C1); RESULT.setLine(C1left); :}
			| (ErrSingleConstDecls) error:l
			{: parser.report_error("Error during const declaration, recovery to semicolon(;) ", lleft); :} {: RESULT=new ErrSingleConstDecls(); :};
			
ConstValue 	::= 
			(NumConst) NUMCONST:N1 {: RESULT=new NumConst(N1); RESULT.setLine(N1left); :} 
			| (CharConst) CHARCONST {: RESULT=new CharConst(); :} 
			| (BoolConst) BOOLCONST {: RESULT=new BoolConst(); :};

VarDecl 	::= 
			(VarDeclaration) Type:T1 VarDecls:V2 SEMI {: RESULT=new VarDeclaration(T1, V2); RESULT.setLine(T1left); :}
			| (ErrLocVarDecl) error:l
			{: parser.report_error("Error during local var or class fields declaration, recovery to left brace({) ", lleft); :} {: RESULT=new ErrLocVarDecl(); :};
			
VarDeclSingle::= 
			(SingleVarDecl) IDENT:I1 VarArr:V2 {: RESULT=new SingleVarDecl(I1, V2); RESULT.setLine(I1left); :};

VarDecls	::= 
			(ListVarDecls) VarDeclSingle:V1 COMMA VarDecls:V2 {: RESULT=new ListVarDecls(V1, V2); RESULT.setLine(V1left); :}
			| (SingleVarDecls) VarDeclSingle:V1 {: RESULT=new SingleVarDecls(V1); RESULT.setLine(V1left); :}
			| (ErrListVarDecls) error:l
			{: parser.report_error("Error during var declaration, recovery to comma(,) ", lleft); :}
			 COMMA VarDecls:V1 {: RESULT=new ErrListVarDecls(V1); RESULT.setLine(V1left); :}
			| (ErrSingleVarDecls) error:l
			{: parser.report_error("Error during var declaration, recovery to semicolon(;) ", lleft); :} {: RESULT=new ErrSingleVarDecls(); :};

VarArr		::= 
			(ArrVar) LBRACKET RBRACKET {: RESULT=new ArrVar(); :}
			| (NotArrVar) {: RESULT=new NotArrVar(); :} /* epsilon */;

ClassDecl	::= 
			(ClassDecl) CLASS IDENT:I1 Extends:E2 LBRACE StaticThings:S3 LocalVarDecls:L4 ClassMethodDecls:C5 RBRACE {: RESULT=new ClassDecl(I1, E2, S3, L4, C5); RESULT.setLine(I1left); :};

Extends		::= 
			(ClassExtends) EXTENDS Type:T1 {: RESULT=new ClassExtends(T1); RESULT.setLine(T1left); :}
			| (ErrClassExtends) error:l
			{: parser.report_error("Error during class extends declaration, recovery to left brace({) ", lleft); :} {: RESULT=new ErrClassExtends(); :}
			| (NoClassExtends) {: RESULT=new NoClassExtends(); :} /* epsilon */;

ClassMethodDecls ::= 
			(ClassMethDecls) LBRACE MethodDecls:M1 RBRACE {: RESULT=new ClassMethDecls(M1); RESULT.setLine(M1left); :}
			| (NoClassMethDecls) {: RESULT=new NoClassMethDecls(); :} /* epsilon */;

StaticThings::= 
			(StaticVarThings) StaticVarDecl:S1 StaticThings:S2 {: RESULT=new StaticVarThings(S1, S2); RESULT.setLine(S1left); :}
            |   (StaticInitThings) StaticInitializer:S1 StaticInitializers:S2 {: RESULT=new StaticInitThings(S1, S2); RESULT.setLine(S1left); :}
			| 	(NoStaticThings) {: RESULT=new NoStaticThings(); :} /* epsilon */;

StaticVarDecl ::= 
			(StaticVarDecl) STATIC VarDecl:V1 {: RESULT=new StaticVarDecl(V1); RESULT.setLine(V1left); :};

StaticInitializers ::= 
			(StaticInits) StaticInitializer:S1 StaticInitializers:S2 {: RESULT=new StaticInits(S1, S2); RESULT.setLine(S1left); :}
			| (NoStaticInits) {: RESULT=new NoStaticInits(); :} /* epsilon */;

StaticInitializer ::= 
			(StaticInit) STATIC LBRACE Statements:S1 RBRACE {: RESULT=new StaticInit(S1); RESULT.setLine(S1left); :};

MethodDecls ::= 
			(MethDeclsRetPars) MethodDecls:M1 Type:T2 IDENT:I3 LPAREN FormPars:F4 RPAREN LocalVarDecls:L5 LBRACE Statements:S6 RBRACE {: RESULT=new MethDeclsRetPars(M1, T2, I3, F4, L5, S6); RESULT.setLine(M1left); :}
			| (ErrMethDeclsRetPars) MethodDecls:M1 Type:T2 IDENT:I3 LPAREN error RPAREN:l 
			{: parser.report_error("Error during formal parameters declaration, recovery to right parenthesis(')') ", lleft); :}
			LocalVarDecls:L4 LBRACE Statements:S5 RBRACE {: RESULT=new ErrMethDeclsRetPars(M1, T2, I3, L4, S5); RESULT.setLine(M1left); :}
			| (MethDeclsVoidPars) MethodDecls:M1 VOID IDENT:I2 LPAREN FormPars:F3 RPAREN LocalVarDecls:L4 LBRACE Statements:S5 RBRACE {: RESULT=new MethDeclsVoidPars(M1, I2, F3, L4, S5); RESULT.setLine(M1left); :}
			| (ErrMethDeclsVoidPars) MethodDecls:M1 VOID IDENT:I2 LPAREN error RPAREN:l 
			{: parser.report_error("Error during formal parameters declaration, recovery to right parenthesis(')') ", lleft); :}
			LocalVarDecls:L3 LBRACE Statements:S4 RBRACE {: RESULT=new ErrMethDeclsVoidPars(M1, I2, L3, S4); RESULT.setLine(M1left); :}
			| (MethDeclsRetNoPars) MethodDecls:M1 Type:T2 IDENT:I3 LPAREN RPAREN LocalVarDecls:L4 LBRACE Statements:S5 RBRACE {: RESULT=new MethDeclsRetNoPars(M1, T2, I3, L4, S5); RESULT.setLine(M1left); :}
			| (MethDeclsVoidNoPars) MethodDecls:M1 VOID IDENT:I2 LPAREN RPAREN LocalVarDecls:L3 LBRACE Statements:S4 RBRACE {: RESULT=new MethDeclsVoidNoPars(M1, I2, L3, S4); RESULT.setLine(M1left); :}
			| (NoMethDecls) {: RESULT=new NoMethDecls(); :} /* epsilon */;
			
LocalVarDecls ::= 
			(LocVarDecls) LocalVarDecls:L1 VarDecl:V2 {: RESULT=new LocVarDecls(L1, V2); RESULT.setLine(L1left); :}  
			| (NoLocVarDecls) {: RESULT=new NoLocVarDecls(); :} /* epsilon */;

FormPars 	::= 
			(SingleFormPars) Type:T1 IDENT:I2 VarArr:V3 {: RESULT=new SingleFormPars(T1, I2, V3); RESULT.setLine(T1left); :}
			| (ListFormPars) FormPars:F1 COMMA Type:T2 IDENT:I3 VarArr:V4 {: RESULT=new ListFormPars(F1, T2, I3, V4); RESULT.setLine(F1left); :}
			| (ErrFormPars) error COMMA:l
			{: parser.report_error("Error during formal parameters declaration, recovery to comma(,) ", lleft); :} {: RESULT=new ErrFormPars(); :};

Type 		::= 
			(TypeSimple) IDENT:I1 {: RESULT=new TypeSimple(I1); RESULT.setLine(I1left); :}
			| (TypeSpecific) IDENT:I1 DOUBLE_COLON IDENT:I2 {: RESULT=new TypeSpecific(I1, I2); RESULT.setLine(I1left); :};

Statements 	::= 
			(Stmnts) Statements:S1 Statement:S2 {: RESULT=new Stmnts(S1, S2); RESULT.setLine(S1left); :}
			| (NoStmnts) {: RESULT=new NoStmnts(); :} /* epsilon */;  
			
Statement 	::= 
			(StmntDesign) DesignStatement:D1 SEMI {: RESULT=new StmntDesign(D1); RESULT.setLine(D1left); :}
			| (StmntIfElse) IF LPAREN Condition:C1 RPAREN Statement:S2 ElseStatement:E3 {: RESULT=new StmntIfElse(C1, S2, E3); RESULT.setLine(C1left); :}
			| (ErrStmntIf) IF LPAREN error RPAREN:l
			{: parser.report_error("Error during if logic conditions declaration, recovery to right parenthesis(')') ", lleft); :}
			Statement:S1 ElseStatement:E2 {: RESULT=new ErrStmntIf(S1, E2); RESULT.setLine(S1left); :}
			| (StmntBreak) BREAK SEMI {: RESULT=new StmntBreak(); :}
			| (StmntContinue) CONTINUE SEMI {: RESULT=new StmntContinue(); :}
			| (StmntRetExpr) RETURN Expr:E1 SEMI {: RESULT=new StmntRetExpr(E1); RESULT.setLine(E1left); :}
			| (StmntRetVoid) RETURN SEMI {: RESULT=new StmntRetVoid(); :}
			| (StmntRead) READ LPAREN Design:D1 RPAREN SEMI {: RESULT=new StmntRead(D1); RESULT.setLine(D1left); :}
			| (StmntPrintNum) PRINT LPAREN Expr:E1 COMMA NUMCONST:N2 RPAREN SEMI {: RESULT=new StmntPrintNum(E1, N2); RESULT.setLine(E1left); :}
			| (StmntPrint) PRINT LPAREN Expr:E1 RPAREN SEMI {: RESULT=new StmntPrint(E1); RESULT.setLine(E1left); :}
			| (StmntFor123) FOR LPAREN DesignStatements:D1 SEMI CondFact:C2 SEMI DesignStatements:D3 RPAREN Statement:S4 {: RESULT=new StmntFor123(D1, C2, D3, S4); RESULT.setLine(D1left); :}
			| (StmntFor12) FOR LPAREN DesignStatements:D1 SEMI CondFact:C2 SEMI RPAREN Statement:S3 {: RESULT=new StmntFor12(D1, C2, S3); RESULT.setLine(D1left); :}
			| (StmntFor13) FOR LPAREN DesignStatements:D1 SEMI SEMI DesignStatements:D2 RPAREN Statement:S3 {: RESULT=new StmntFor13(D1, D2, S3); RESULT.setLine(D1left); :}
			| (StmntFor1) FOR LPAREN DesignStatements:D1 SEMI SEMI RPAREN Statement:S2 {: RESULT=new StmntFor1(D1, S2); RESULT.setLine(D1left); :}
			| (StmntFor23) FOR LPAREN SEMI CondFact:C1 SEMI DesignStatements:D2 RPAREN Statement:S3 {: RESULT=new StmntFor23(C1, D2, S3); RESULT.setLine(C1left); :}
			| (StmntFor2) FOR LPAREN SEMI CondFact:C1 SEMI RPAREN Statement:S2 {: RESULT=new StmntFor2(C1, S2); RESULT.setLine(C1left); :}
			| (StmntFor3) FOR LPAREN SEMI SEMI DesignStatements:D1 RPAREN Statement:S2 {: RESULT=new StmntFor3(D1, S2); RESULT.setLine(D1left); :}
			| (StmntFor) FOR LPAREN SEMI SEMI RPAREN Statement:S1 {: RESULT=new StmntFor(S1); RESULT.setLine(S1left); :}
			| (StmntBlock) LBRACE Statements:S1 RBRACE {: RESULT=new StmntBlock(S1); RESULT.setLine(S1left); :};
			
ElseStatement ::= 
			(StmntElse) ELSE Statement:S1 {: RESULT=new StmntElse(S1); RESULT.setLine(S1left); :}
			| (StmntNoElse) {: RESULT=new StmntNoElse(); :} /* epsilon */;
			
DesignStatements ::= 
			(SingleDesignStmnts) DesignStatement:D1 {: RESULT=new SingleDesignStmnts(D1); RESULT.setLine(D1left); :}
			| (ListDesignStmnts) DesignStatements:D1 COMMA DesignStatement:D2 {: RESULT=new ListDesignStmnts(D1, D2); RESULT.setLine(D1left); :};

DesignStatement ::= 
			(DesignAssignment) Design:D1 ASSIGN Expr:E2 {: RESULT=new DesignAssignment(D1, E2); RESULT.setLine(D1left); :}
			| (DesignMethDeclPars) Design:D1 LPAREN ActPars:A2 RPAREN {: RESULT=new DesignMethDeclPars(D1, A2); RESULT.setLine(D1left); :}
			| (DesignMethDeclNoPars) Design:D1 LPAREN RPAREN {: RESULT=new DesignMethDeclNoPars(D1); RESULT.setLine(D1left); :}
			| (DesignInc) Design:D1 INC {: RESULT=new DesignInc(D1); RESULT.setLine(D1left); :}
			| (DesignDec) Design:D1 DEC {: RESULT=new DesignDec(D1); RESULT.setLine(D1left); :}
			| (DesignMultiAssignment) LBRACKET Designs:D1 MUL Design:D2 RBRACKET ASSIGN Design:D3 {: RESULT=new DesignMultiAssignment(D1, D2, D3); RESULT.setLine(D1left); :}
			| (ErrDesign) error SEMI:l
			{: parser.report_error("Error during assignment construction, recovery to semicolon(;) ", lleft); :} {: RESULT=new ErrDesign(); :};

Designs 	::= 
			(DesignsListNoDesign) Designs:D1 COMMA {: RESULT=new DesignsListNoDesign(D1); RESULT.setLine(D1left); :}
			| (DesignsListDesign) Designs:D1 COMMA Design:D2 {: RESULT=new DesignsListDesign(D1, D2); RESULT.setLine(D1left); :}
			| (NoDesignsList) {: RESULT=new NoDesignsList(); :} /* epsilon */;
			
ActPars 	::= 
			(SingleActPars) Expr:E1 {: RESULT=new SingleActPars(E1); RESULT.setLine(E1left); :}
			| (ListActPars) ActPars:A1 COMMA Expr:E2 {: RESULT=new ListActPars(A1, E2); RESULT.setLine(A1left); :};

Condition 	::= 
			(NoCondOr) CondTerm:C1 {: RESULT=new NoCondOr(C1); RESULT.setLine(C1left); :}
			| (CondOr) Condition:C1 OR CondTerm:C2 {: RESULT=new CondOr(C1, C2); RESULT.setLine(C1left); :};
			
CondTerm 	::= 
			(NoCondAnd) CondFact:C1 {: RESULT=new NoCondAnd(C1); RESULT.setLine(C1left); :}
			| (CondAnd) CondTerm:C1 AND CondFact:C2 {: RESULT=new CondAnd(C1, C2); RESULT.setLine(C1left); :};
			
CondFact 	::= 
			(CondRelops) Expr:E1 Relops:R2 Expr:E3 {: RESULT=new CondRelops(E1, R2, E3); RESULT.setLine(E1left); :}
			| (NoCondRelops) Expr:E1 {: RESULT=new NoCondRelops(E1); RESULT.setLine(E1left); :};

Expr 		::= 
			(NoAddopsExprNeg) MINUS Term:T1 {: RESULT=new NoAddopsExprNeg(T1); RESULT.setLine(T1left); :}
			| (NoAddopsExpr) Term:T1 {: RESULT=new NoAddopsExpr(T1); RESULT.setLine(T1left); :}
			| (AddopsExpr) Expr:E1 Addops:A2 Term:T3 {: RESULT=new AddopsExpr(E1, A2, T3); RESULT.setLine(E1left); :};
			
Term 		::= 
			(NoMulopsTerm) Factor:F1 {: RESULT=new NoMulopsTerm(F1); RESULT.setLine(F1left); :}
			| (MulopsTerm) Term:T1 Mulops:M2 Factor:F3 {: RESULT=new MulopsTerm(T1, M2, F3); RESULT.setLine(T1left); :};
			
Factor 		::= 
			(FactorDesignPars) Design:D1 LPAREN ActPars:A2 RPAREN {: RESULT=new FactorDesignPars(D1, A2); RESULT.setLine(D1left); :}
			| (FactorDesignNoPars) Design:D1 LPAREN RPAREN {: RESULT=new FactorDesignNoPars(D1); RESULT.setLine(D1left); :}
			| (FactorDesign) Design:D1 {: RESULT=new FactorDesign(D1); RESULT.setLine(D1left); :}
			| (FactorConst) ConstValue:C1 {: RESULT=new FactorConst(C1); RESULT.setLine(C1left); :}
			| (FactorNewArr) NEW Type:T1 LBRACKET Expr:E2 RBRACKET {: RESULT=new FactorNewArr(T1, E2); RESULT.setLine(T1left); :}
			| (FactorNewPars) NEW Type:T1 LPAREN ActPars:A2 RPAREN {: RESULT=new FactorNewPars(T1, A2); RESULT.setLine(T1left); :}
			| (FactorNewNoPars) NEW Type:T1 LPAREN RPAREN {: RESULT=new FactorNewNoPars(T1); RESULT.setLine(T1left); :}
			| (FactorInParens) LPAREN Expr:E1 RPAREN {: RESULT=new FactorInParens(E1); RESULT.setLine(E1left); :};

Design 		::= (DesignSpecific) IDENT:I1 DOUBLE_COLON IDENT:I2 DesignPart:D3 {: RESULT=new DesignSpecific(I1, I2, D3); RESULT.setLine(I1left); :}
			| (DesignSimple) IDENT:I1 DesignPart:D2 {: RESULT=new DesignSimple(I1, D2); RESULT.setLine(I1left); :};

DesignPart 	::= (ListDesignField) DesignPart:D1 DOT IDENT:I2 {: RESULT=new ListDesignField(D1, I2); RESULT.setLine(D1left); :}
			| (ListDesignIndex) DesignPart:D1 LBRACKET Expr:E2 RBRACKET {: RESULT=new ListDesignIndex(D1, E2); RESULT.setLine(D1left); :}
			| (NoListDesign) {: RESULT=new NoListDesign(); :};
			
Relops 		::= (EqualOp) EQUAL {: RESULT=new EqualOp(); :}
			| (NotEqualOp) NOT_EQUAL {: RESULT=new NotEqualOp(); :}
			| (GreaterOp) GREATER_THAN {: RESULT=new GreaterOp(); :}
			| (GreaterEqualOp) GREATER_EQUAL {: RESULT=new GreaterEqualOp(); :}
			| (LessOp) LESS_THAN {: RESULT=new LessOp(); :}
			| (LessEqualOp) LESS_EQUAL {: RESULT=new LessEqualOp(); :};
			
Addops 		::= (AddOp) PLUS {: RESULT=new AddOp(); :}
			| (SubOp) MINUS {: RESULT=new SubOp(); :};
			
Mulops 		::= (MulOp) MUL {: RESULT=new MulOp(); :}
			| (DivOp) DIV {: RESULT=new DivOp(); :}
			| (ModOp) MOD {: RESULT=new ModOp(); :};